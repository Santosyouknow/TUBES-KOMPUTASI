#!/usr/bin/env python3
"""
Stress Testing Script untuk Todo App
Menguji batas maksimum aplikasi dengan increasing load
"""

import requests
import threading
import time
import json
import random
import statistics
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import argparse
import sys

class TodoStressTester:
    def __init__(self, base_url="http://localhost", max_users=100, ramp_up_time=300):
        self.base_url = base_url
        self.max_users = max_users
        self.ramp_up_time = ramp_up_time
        self.results = []
        self.errors = []
        self.active_users = 0
        self.test_running = True
        self.lock = threading.Lock()
        
        # Performance thresholds
        self.response_time_threshold = 5000  # 5 seconds
        self.error_rate_threshold = 5  # 5%
        
    def make_request(self, method, endpoint, data=None):
        """Make HTTP request and record metrics"""
        url = f"{self.base_url}{endpoint}"
        start_time = time.time()
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=30)
            elif method == "POST":
                response = requests.post(url, json=data, timeout=30)
            elif method == "PATCH":
                response = requests.patch(url, json=data, timeout=30)
            elif method == "DELETE":
                response = requests.delete(url, timeout=30)
            
            end_time = time.time()
            response_time = (end_time - start_time) * 1000
            
            with self.lock:
                result = {
                    'method': method,
                    'endpoint': endpoint,
                    'status_code': response.status_code,
                    'response_time': response_time,
                    'timestamp': datetime.now(),
                    'success': response.status_code < 400,
                    'active_users': self.active_users
                }
                self.results.append(result)
            
            return response
            
        except Exception as e:
            end_time = time.time()
            response_time = (end_time - start_time) * 1000
            
            with self.lock:
                error = {
                    'method': method,
                    'endpoint': endpoint,
                    'error': str(e),
                    'response_time': response_time,
                    'timestamp': datetime.now(),
                    'active_users': self.active_users
                }
                self.errors.append(error)
            
            return None
    
    def user_simulation(self, user_id):
        """Simulate user behavior under stress"""
        with self.lock:
            self.active_users += 1
        
        try:
            while self.test_running:
                # Aggressive user behavior for stress testing
                actions = [
                    ('GET', '/todos'),
                    ('POST', '/todos', {
                        'title': f'Stress Test Todo {user_id}-{int(time.time())}',
                        'completed': random.choice([True, False]),
                        'description': f'Generated by stress test user {user_id}'
                    }),
                    ('GET', '/stats'),
                    ('GET', '/health')
                ]
                
                method, endpoint, data = random.choice(actions) if len(actions[0]) == 3 else (*random.choice(actions), None)
                self.make_request(method, endpoint, data)
                
                # Minimal delay for stress testing
                time.sleep(random.uniform(0.01, 0.1))
                
        finally:
            with self.lock:
                self.active_users -= 1
    
    def monitor_performance(self):
        """Monitor performance metrics during test"""
        print("Starting performance monitoring...")
        
        while self.test_running:
            time.sleep(10)  # Check every 10 seconds
            
            # Calculate recent performance (last 30 seconds)
            recent_time = datetime.now().timestamp() - 30
            recent_results = [
                r for r in self.results 
                if r['timestamp'].timestamp() > recent_time
            ]
            
            if recent_results:
                # Calculate metrics
                avg_response_time = statistics.mean([r['response_time'] for r in recent_results])
                error_count = len([r for r in recent_results if not r['success']])
                error_rate = (error_count / len(recent_results)) * 100
                rps = len(recent_results) / 30
                
                print(f"[{datetime.now().strftime('%H:%M:%S')}] "
                      f"Users: {self.active_users:3d} | "
                      f"RPS: {rps:6.1f} | "
                      f"Avg RT: {avg_response_time:7.1f}ms | "
                      f"Error Rate: {error_rate:5.1f}%")
                
                # Check if we've hit performance limits
                if (avg_response_time > self.response_time_threshold or 
                    error_rate > self.error_rate_threshold):
                    print(f"‚ö†Ô∏è  Performance threshold exceeded!")
                    print(f"   Response Time: {avg_response_time:.1f}ms (threshold: {self.response_time_threshold}ms)")
                    print(f"   Error Rate: {error_rate:.1f}% (threshold: {self.error_rate_threshold}%)")
    
    def run_stress_test(self):
        """Run stress test with gradually increasing load"""
        print(f"Starting stress test: 0 ‚Üí {self.max_users} users over {self.ramp_up_time} seconds")
        print(f"Target URL: {self.base_url}")
        print("-" * 80)
        
        # Start performance monitoring
        monitor_thread = threading.Thread(target=self.monitor_performance)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        start_time = time.time()
        users_started = 0
        
        with ThreadPoolExecutor(max_workers=self.max_users) as executor:
            futures = []
            
            # Gradually ramp up users
            while users_started < self.max_users and self.test_running:
                # Calculate how many users should be active at this time
                elapsed = time.time() - start_time
                target_users = min(self.max_users, int((elapsed / self.ramp_up_time) * self.max_users))
                
                # Start new users if needed
                while users_started < target_users:
                    future = executor.submit(self.user_simulation, users_started + 1)
                    futures.append(future)
                    users_started += 1
                    time.sleep(0.1)  # Small delay between starting users
                
                time.sleep(1)  # Check every second
            
            print(f"\nüöÄ All {self.max_users} users started! Running stress test...")
            
            # Let the test run for additional time after ramp-up
            additional_time = 120  # 2 minutes of full load
            time.sleep(additional_time)
            
            print("\nüõë Stopping stress test...")
            self.test_running = False
            
            # Wait for all users to finish
            for future in futures:
                try:
                    future.result(timeout=30)
                except:
                    pass
    
    def analyze_breaking_point(self):
        """Analyze at what point the system started to degrade"""
        if not self.results:
            return None
        
        # Group results by user count ranges
        user_ranges = {}
        for result in self.results:
            user_count = result['active_users']
            range_key = (user_count // 10) * 10  # Group by 10s
            
            if range_key not in user_ranges:
                user_ranges[range_key] = []
            user_ranges[range_key].append(result)
        
        print("\nPERFORMANCE BY USER COUNT:")
        print("-" * 60)
        
        breaking_point = None
        
        for user_range in sorted(user_ranges.keys()):
            results = user_ranges[user_range]
            
            avg_response_time = statistics.mean([r['response_time'] for r in results])
            error_count = len([r for r in results if not r['success']])
            error_rate = (error_count / len(results)) * 100
            
            status = "‚úÖ Good"
            if avg_response_time > self.response_time_threshold or error_rate > self.error_rate_threshold:
                status = "‚ùå Degraded"
                if breaking_point is None:
                    breaking_point = user_range
            
            print(f"{user_range:3d}-{user_range+9:3d} users: "
                  f"Avg RT: {avg_response_time:7.1f}ms | "
                  f"Error Rate: {error_rate:5.1f}% | "
                  f"{status}")
        
        return breaking_point
    
    def generate_report(self):
        """Generate comprehensive stress test report"""
        if not self.results:
            print("No results to report!")
            return
        
        # Basic statistics
        total_requests = len(self.results)
        successful_requests = [r for r in self.results if r['success']]
        failed_requests = [r for r in self.results if not r['success']]
        
        response_times = [r['response_time'] for r in self.results]
        avg_response_time = statistics.mean(response_times)
        max_response_time = max(response_times)
        p95_response_time = statistics.quantiles(response_times, n=20)[18]
        p99_response_time = statistics.quantiles(response_times, n=100)[98]
        
        success_rate = (len(successful_requests) / total_requests) * 100
        
        print("\n" + "="*80)
        print("STRESS TEST RESULTS")
        print("="*80)
        print(f"Maximum Users Tested: {self.max_users}")
        print(f"Ramp-up Time: {self.ramp_up_time} seconds")
        print(f"Total Requests: {total_requests}")
        print(f"Success Rate: {success_rate:.2f}%")
        print()
        
        print("RESPONSE TIME ANALYSIS:")
        print(f"  Average: {avg_response_time:.2f} ms")
        print(f"  Maximum: {max_response_time:.2f} ms")
        print(f"  95th Percentile: {p95_response_time:.2f} ms")
        print(f"  99th Percentile: {p99_response_time:.2f} ms")
        print()
        
        # Analyze breaking point
        breaking_point = self.analyze_breaking_point()
        
        if breaking_point:
            print(f"\nüî• BREAKING POINT DETECTED: ~{breaking_point} concurrent users")
            print("   System performance degraded beyond acceptable thresholds")
        else:
            print(f"\n‚úÖ SYSTEM STABLE: Handled {self.max_users} concurrent users successfully")
        
        print("\nRECOMMENDations:")
        if breaking_point and breaking_point < 50:
            print("  - System needs significant optimization")
            print("  - Consider horizontal scaling")
            print("  - Review database connection pooling")
            print("  - Implement caching strategies")
        elif breaking_point and breaking_point < 100:
            print("  - Good performance for moderate load")
            print("  - Consider load balancing for higher traffic")
            print("  - Monitor resource usage")
        else:
            print("  - Excellent performance under stress")
            print("  - System is well-optimized")
            print("  - Ready for production load")
        
        print("="*80)

def main():
    parser = argparse.ArgumentParser(description='Stress test for Todo App')
    parser.add_argument('--url', default='http://localhost',
                       help='Base URL of the application')
    parser.add_argument('--max-users', type=int, default=100,
                       help='Maximum number of concurrent users')
    parser.add_argument('--ramp-up', type=int, default=300,
                       help='Ramp-up time in seconds')
    
    args = parser.parse_args()
    
    tester = TodoStressTester(
        base_url=args.url,
        max_users=args.max_users,
        ramp_up_time=args.ramp_up
    )
    
    try:
        tester.run_stress_test()
        tester.generate_report()
        
    except KeyboardInterrupt:
        print("\nStress test interrupted by user")
        tester.test_running = False
        if tester.results:
            tester.generate_report()

if __name__ == "__main__":
    main()